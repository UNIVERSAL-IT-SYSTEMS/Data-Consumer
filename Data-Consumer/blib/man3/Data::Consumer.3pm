.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Consumer 3"
.TH Data::Consumer 3 "2008-02-17" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Data::Consumer \- Repeatedly consume a data resource in a robust way
.SH "VERSION"
.IX Header "VERSION"
Version 0.08
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Data::Consumer;
.Ve
.PP
.Vb 10
\&    my $consumer = Data::Consumer\->new(
\&        type        => $consumer_name,
\&        unprocessed => $unprocessed,
\&        working     => $working,
\&        processed   => $processed,
\&        failed      => $failed,
\&        max_passes  => $num_or_undef,
\&        max_process => $num_or_undef,
\&        max_elapsed => $seconds_or_undef,
\&    );
.Ve
.PP
.Vb 4
\&    $consumer\->consume( sub {
\&        my $id = shift;
\&        print "processed $id\en";
\&    } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It is a common requirement to need to process a feed of items of some 
sort in a robust manner. Such a feed might be records that are inserted 
into a table, or files dropped in a delivery directory.
Writing a script that handles all the edge cases, like getting \*(L"stuck\*(R"
on a failed item, and manages things like locking so that the script 
can be parallelized can be tricky and is certainly repetitive.
.PP
The aim of Data::Consumer is to provide a framework to allow writing
such consumer type scripts as easy as writing a callback that processes
each item. The framework handles the rest.
.PP
The basic idea is that one need only use, or in the case of a feed type 
not already supported, define a Data::Consumer subclass
which implements a few reasonably well defined primitive methods which 
handle the required tasks, and then the Data::Consumer methods use 
those to provide a DWIMily consistant interface to the end consumer.
.PP
Currently Data::Consumer is distributed with two subclasses,
Data::Consumer::MySQL for handling records in a MySQL db (using the
MySQL \f(CW\*(C`GET_LOCK()\*(C'\fR function), and Data::Consumer::Dir for handling
a drop directory scenario (like for \s-1FTP\s0 or a mail directory).
.PP
Once a resource type has been defined as a Data::Consumer subclass
the use pattern is to construct the subclass with the appropriate
arguments, and then call consume with a callback.
.Sh "The Consumer Pattern"
.IX Subsection "The Consumer Pattern"
The consumer pattern is where code wants to consume an 'atomic' resource
piece by piece. The consuming codes doesnt really want to worry much 
about how they got the piece a task that should be handled by the framework. 
The consumer subclasses assume that the resource can be modeled as a 
queue (that there is some ordering principle by which they can be processed 
in a predictable sequence). The consume pattern in full glory is something 
very close to the following following pseudo code. The items marked with 
asterixs are where user callbacks may be invoked:
.PP
.Vb 13
\&    DO
\&        RESET TO THE BEGINNING OF THE QUEUE
\&        WHILE QUEUE NOT EMPTY AND CAN *PROCEED*
\&            ACQUIRE NEXT ITEM TO PROCESS FROM QUEUE
\&            MARK AS 'WORKING'
\&            *PROCESS* ITEM 
\&            IF PROCESSING FAILED
\&                MARK AS 'FAILED'
\&            OTHERWISE 
\&                MARK AS 'PROCESSED'
\&        SWEEP UP ABANDONDED 'WORKING' ITEMS AND MARK THEM AS 'FAILED'
\&    UNTIL WE CANNOT *PROCEED* OR NOTHING WAS PROCESSED
\&    RELEASE ANY LOCKS STILL HELD
.Ve
.PP
This implies that each item potentially has four states: \f(CW\*(C`unprocessed\*(C'\fR,
\&\f(CW\*(C`working\*(C'\fR, \f(CW\*(C`processed\*(C'\fR and \f(CW\*(C`failed\*(C'\fR. In a database these might be
values in a field, in a drop directory scenario these would be different
directories, but with all of them they would normally be supplied as
values to the Data::Consumer subclass being created. 
.Sh "Subclassing Data::Consumer"
.IX Subsection "Subclassing Data::Consumer"
Data::Consumer can be used with any resource type that can be modeled
as a queue, supports some form of advisory locking mechanism, and
provides a way to discriminate between at least the \f(CW\*(C`unprocessed\*(C'\fR and
\&\f(CW\*(C`processed\*(C'\fR state.
.PP
The routines that must be defined for a new consumer type are \f(CW\*(C`new()\*(C'\fR,
\&\f(CW\*(C`reset()\*(C'\fR, \f(CW\*(C`acquire()\*(C'\fR, \f(CW\*(C`release()\*(C'\fR, and \f(CW\*(C`_mark_as()\*(C'\fR,
\&\f(CW\*(C`_do_callback()\*(C'\fR, and possibly \f(CW\*(C`_fix_sweeper()\*(C'\fR.
.IP "new" 4
.IX Item "new"
It is almost for sure that a subclass will need to override the default
constructor.  All Data::Consumer objects are blessed hashes, and in
fact you should always call the parents classes constructor first with:
.Sp
.Vb 1
\&    my $self= $class\->SUPER::new();
.Ve
.IP "reset" 4
.IX Item "reset"
This routine is used to reset the objects internal state so the next call to acquire
will return the first available item in the queue.
.IP "acquire" 4
.IX Item "acquire"
This routine is to find and in some way lock the next item in the queue.
.IP "release" 4
.IX Item "release"
This routine is to release any held locks in the object. 
.IP "_mark_as" 4
.IX Item "_mark_as"
This routine is called to \*(L"mark\*(R" an item as a particular state. It
should be able to handle user supplied values. For instance
Data::Consumer::MySQL implements this as an update statement that
mapps user supplied values to the consumer state names.
.Sp
Possible states are: \f(CW\*(C`unprocessed\*(C'\fR, \f(CW\*(C`working\*(C'\fR, \f(CW\*(C`processed\*(C'\fR,
\&\f(CW\*(C`failed\*(C'\fR.
.IP "_do_callback" 4
.IX Item "_do_callback"
This routine is used to call the user supplied callback with the correct
arguments.  What arguments are appropriate for the callback are context
dependent on the type of class. For instance in Data::Consumer::MySQL
calls the callback with the arguments \f(CW\*(C`($consumer, $id, $dbh)\*(C'\fR whereas
Data::Consumer::Dir calls the callback with the arguments
\&\f(CW\*(C`($consumer, $filespec, $filehandle, $filename)\*(C'\fR. The point is that the
end user should be passed the arguments that make sense, not necessarily
the same thing for each consumer type.
.IP "_fixup_sweeper" 4
.IX Item "_fixup_sweeper"
Data::Consumer has support for a \*(L"sweep\-up\*(R" mode for handling things
that were abandonded in the \f(CW\*(C`working\*(C'\fR state and moving them to the
\&\f(CW\*(C`failed\*(C'\fR state. This is mostly a sanity check to prevent things like
powerfailures and segfaults leaving an item in a partially or
unprocessed state without it being properly marked as failed. In order
to do this the Data::Consumer subclass actually creates a private
near clone of itself. \f(CW\*(C`_fix_sweeper()\*(C'\fR is called in case the normal
modifications done by the base class routine are not sufficient for a
subclass. As an example Data::Consumer::MySQL provides this hook
while Data::Consumer::Dir does not.
.PP
Every well-behaved Data::Consumer subclass should include the 
functional equivalent of the following code in its .pm file:
.PP
.Vb 2
\&    use base 'Data::Consumer';
\&    __PACKAGE__\->register();
.Ve
.PP
This will ensure that it can be properly loaded by 
\&\f(CW\*(C`Data::Consumer\-\*(C'\fRnew(type=>$shortname)>. 
.PP
It is also normal for a Data::Consumer subclass to provide special
methods as needed. For instance \f(CW\*(C`Data::Consumer::Dir\-\*(C'\fR\fIfh()\fR> and
\&\f(CW\*(C`Data::Consumer::MySQL\-\*(C'\fR\fIdbh()\fR>.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\s-1CLASS\-\s0>new(%opts)"
.IX Subsection "CLASS->new(%opts)"
Constructor. Normally Data::Consumer's constructor is not called
directly, instead the constructor of a subclass is used.  However to
make it easier to have a data driven load process  Data::Consumer
accepts the \f(CW\*(C`type\*(C'\fR argument which should specify the the short name of
the subclass (the part after \f(CW\*(C`Data::Consumer::\*(C'\fR) or the full name of
the subclass.
.PP
Thus
.PP
.Vb 1
\&    Data::Consumer\->new(type=>'MySQL',%args);
.Ve
.PP
is exactly equivalent to calling
.PP
.Vb 1
\&    Data::Consumer::MySQL\->new(%args);
.Ve
.PP
except that the former will automatically require or use the appropriate module 
and the latter necessitates that you do so yourself.
.PP
Every Data::Consumer subclass constructor supports the following
arguments on top of any that are subclass specific. Additionally some
arguments are universally used, but have different meaning depending on
the subclass. 
.IP "unprocessed" 4
.IX Item "unprocessed"
How to tell if the item is unprocessed. 
.Sp
How this argument is interpreted depends on the Data::Consumer
subclass involved.
.IP "working" 4
.IX Item "working"
How to tell if the item is currently being worked on.
.Sp
How this argument is interpreted depends on the Data::Consumer
subclass involved.
.IP "processed" 4
.IX Item "processed"
How to tell if the item has already been worked on.
.Sp
How this argument is interpreted depends on the Data::Consumer
subclass involved.
.IP "failed" 4
.IX Item "failed"
How to tell if processing failed while handling the item.
.Sp
How this argument is interpreted depends on the Data::Consumer
subclass involved.
.ie n .IP "max_passes => $num_or_undef" 4
.el .IP "max_passes => \f(CW$num_or_undef\fR" 4
.IX Item "max_passes => $num_or_undef"
Normally \f(CW\*(C`consume()\*(C'\fR will loop through the data set until it is
exhausted.  By setting this parameter you can control the maximum number
of iterations, for instance setting it to \f(CW1\fR will result in a single
pass through the data per invocation. If \f(CW0\fR (or any other false value)
is treated as meaning \*(L"loop until exhausted\*(R".
.ie n .IP "max_processed => $num_or_undef" 4
.el .IP "max_processed => \f(CW$num_or_undef\fR" 4
.IX Item "max_processed => $num_or_undef"
Maximum number of items to process per invocation.
.Sp
If set to a false value there is no limit.
.ie n .IP "max_failed => $num_or_undef" 4
.el .IP "max_failed => \f(CW$num_or_undef\fR" 4
.IX Item "max_failed => $num_or_undef"
Maximum number of failed process attempts that may occur before consume will stop.
If set to a false value there is no limit. Setting this to 1 will cause processing
to stop after the first failure.
.ie n .IP "max_elapsed => $seconds_or_undef" 4
.el .IP "max_elapsed => \f(CW$seconds_or_undef\fR" 4
.IX Item "max_elapsed => $seconds_or_undef"
Maximum amount of time that may have elapsed when starting a new
process. If more than this value has elapsed then no further processing
occurs. If \f(CW0\fR (or any false value) then there is no time limit.
.ie n .IP "proceed => $code_ref" 4
.el .IP "proceed => \f(CW$code_ref\fR" 4
.IX Item "proceed => $code_ref"
This is a callback that may be used to control the looping process in
consume via the \f(CW\*(C`proceed()\*(C'\fR method. See the documentation of
\&\f(CW\*(C`consume()\*(C'\fR and \f(CW\*(C`proceed()\*(C'\fR
.ie n .IP "sweep => $bool" 4
.el .IP "sweep => \f(CW$bool\fR" 4
.IX Item "sweep => $bool"
If this parameter is true, and there are four modes defined
(\f(CW\*(C`unprocessed\*(C'\fR, \f(CW\*(C`working\*(C'\fR, \f(CW\*(C`processed\*(C'\fR, \f(CW\*(C`failed\*(C'\fR) then consume will
perform a \*(L"sweep up\*(R" after every pass, which is responsible for moving
\&\*(L"abandonded\*(R" files from the working directory (such as from a previous
process that segfaulted during processing). Generally this should
not be necessary.
.Sh "\s-1CLASS\-\s0>register(@alias)"
.IX Subsection "CLASS->register(@alias)"
Used by subclasses to register themselves as a Data::Consumer
subclass and register any additional aliases that the class may be
identified as.
.PP
Will throw an exception if any of the aliases are already associated to
a different class.
.PP
When called on a subclass in list context returns a list of the
subclasses registered aliases,
.PP
If called on Data::Consumer in list context returns a list of all
alias class mappings.
.Sh "$class_or_object\->debug_warn($level,@debug_lines)"
.IX Subsection "$class_or_object->debug_warn($level,@debug_lines)"
If \f(CW\*(C`Debug\*(C'\fR is enabled and above \f(CW$level\fR then print \f(CW@debug_lines\fR to
\&\f(CW\*(C`STDOUT\*(C'\fR in a specific format that includes the class name of the
caller and process id.
.Sh "$object\->\fIlast_id()\fP"
.IX Subsection "$object->last_id()"
Returns the identifier for the last item acquired.
.PP
Returns undef if acquire has never been called or if the last
attempt to acquire data failed because none was available.
.Sh "$object\->mark_as($type)"
.IX Subsection "$object->mark_as($type)"
Mark an item as a particular type if the object defines that type.
.PP
Allowed types are \f(CW\*(C`unprocessed\*(C'\fR, \f(CW\*(C`working\*(C'\fR, \f(CW\*(C`processed\*(C'\fR, \f(CW\*(C`failed\*(C'\fR
.Sh "$object\->process($callback)"
.IX Subsection "$object->process($callback)"
Marks the current item as \f(CW\*(C`working\*(C'\fR and processes it using the
\&\f(CW$callback\fR. If the \f(CW$callback\fR dies then the item is marked as
\&\f(CW\*(C`failed\*(C'\fR, otherwise the item is marked as \f(CW\*(C`processed\*(C'\fR once the
\&\f(CW$callback\fR returns. The return value of the \f(CW$callback\fR is ignored.
.PP
\&\f(CW$callback\fR will be called with at least two arguments, the first being
the \f(CW$consumer\fR object itself, and the second being an identifier for the
current record. Normally additional, likely to be useful, arguments are 
provided as well, on a per subclass basis. For example 
Data::Consumer::MySQL will pass in the consumer object, the id of the to 
be processed record, and a copy of the consumers database handle as well for 
convenience. On the other hand Data::Consumer::Dir will pass in the 
consumer object, followed by a filespecification for the file to be 
processed, an open filehandle to the file, and the filename itself (with 
no path).
.PP
For further details always consult the relevent subclasses documentation for
\&\f(CW\*(C`process()\*(C'\fR
.Sh "$object\->\fIreset()\fP"
.IX Subsection "$object->reset()"
Reset the state of the object.
.Sh "$object\->\fIacquire()\fP"
.IX Subsection "$object->acquire()"
Aquire an item to be processed.
.PP
returns an identifier to be used to identify the item acquired.
.Sh "$object\->\fIrelease()\fP"
.IX Subsection "$object->release()"
Release any locks on the currently held item.
.PP
Normally there is no need to call this directly.
.Sh "$object\->\fIerror()\fP"
.IX Subsection "$object->error()"
Calls the \f(CW\*(C`error\*(C'\fR callback if the user has provided one, otherwise
calls \f(CW\*(C`confess()\*(C'\fR. Probably not all that useful for an end user.
.Sh "$object\->consume($callback)"
.IX Subsection "$object->consume($callback)"
Consumes a data resource until it is exhausted using \f(CW\*(C`acquire()\*(C'\fR,
\&\f(CW\*(C`process()\*(C'\fR, and \f(CW\*(C`release()\*(C'\fR as appropriate. Normally this is the main
method used by external processes.
.PP
Before each attempt to acquire a new resource, and once at the end of
each pass consume will call \f(CW\*(C`proceed()\*(C'\fR to determine if it can do so.
The user may hook into this by specifying a callback in the constructor.
This callback will be executed with no args when it is in the inner loop
(per item), and with the number of passes at the end of each pass
(starting with 1).
.Sh "$object\->proceed($passes)"
.IX Subsection "$object->proceed($passes)"
Returns \f(CW\*(C`true\*(C'\fR if the conditions specified at construction time are
satisfied and processing may proceed. Returns \f(CW\*(C`false\*(C'\fR otherwise.
.PP
If the user has specified a \f(CW\*(C`proceed\*(C'\fR callback in the constructor then
this will be executed before any other rules are applied, with a
reference to the current \f(CW$object\fR, a reference to the runstats, and if
being called at the end of pass with the number of passes.
.PP
If this callback returns \f(CW\*(C`true\*(C'\fR then the other rules will be applied,
and only if all other conditions from the constructor are satisfied
will \f(CW\*(C`proceed()\*(C'\fR itself return \f(CW\*(C`true\*(C'\fR.
.Sh "$object\->\fIsweep()\fP"
.IX Subsection "$object->sweep()"
If the user has specified both a \f(CW\*(C`working\*(C'\fR and a \f(CW\*(C`failed\*(C'\fR state then
this routine will move all lockable \f(CW\*(C`working\*(C'\fR items and change them to
the \f(CW\*(C`failed\*(C'\fR state. This is to catch catastrophic failures where
unprocessed items are left in the working state. Presumably this is a
rare case.
.Sh "$object\->\fIrunstats()\fP"
.IX Subsection "$object->runstats()"
Returns a reference to a hash of statistics about the last (or currently running)
execution of consume.
.SH "AUTHOR"
.IX Header "AUTHOR"
Yves Orton, \f(CW\*(C`<YVES at cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-data\-consumer at rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Data\-Consumer>.
.PP
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Data::Consumer
.Ve
.PP
You can also look for information at:
.IP "* \s-1RT:\s0 \s-1CPAN\s0's request tracker" 4
.IX Item "RT: CPAN's request tracker"
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Data\-Consumer>
.IP "* AnnoCPAN: Annotated \s-1CPAN\s0 documentation" 4
.IX Item "AnnoCPAN: Annotated CPAN documentation"
<http://annocpan.org/dist/Data\-Consumer>
.IP "* \s-1CPAN\s0 Ratings" 4
.IX Item "CPAN Ratings"
<http://cpanratings.perl.org/d/Data\-Consumer>
.IP "* Search \s-1CPAN\s0" 4
.IX Item "Search CPAN"
<http://search.cpan.org/dist/Data\-Consumer>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Igor Sutton for ideas, testing and support.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008 Yves Orton, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
